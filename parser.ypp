%{
    #include "hw3_output.hpp"
    
    #include <iostream>
    #include <string>
    #include "symbol_tables_stack.hpp"
    
    extern int yylineno;
    int yylex();
    void yyerror(const char*);
    
    using namespace output;

    symbol_tables_stack _stack = symbol_tables_stack();
    bool notBool( string type);
    bool byteTooLarge(int value);
    bool typesDontMatch( string LHS_type,  string RHS_type);
    bool notIntOrBool( string converter_type,  string converted_type);
    bool isFunc(string type);
    bool expList_not_valid(string func_name, string exp_list);
    bool isVoid();
    string biggerType(string first, string second);






    
%}
%define parse.error verbose;
%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc OVERRIDE;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;

%token V;
%token ERROR;
%nonassoc IF;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc LBRACE;
%nonassoc RBRACE;
%nonassoc ID;                                                                      
%nonassoc NUM;    
%nonassoc STRING;

%right ASSIGN;

%left OR;
%left AND;


%left EQ_RELOP;
%left RE_RELOP;
%left PM_BINOP;
%left MD_BINOP;

%right NOT;
%left LPAREN;
%left RPAREN;
%nonassoc ELSE;

%%
Program
    : Funcs {
        if (yychar == YYEOF) {
            _stack.validateMainFunction();
        }
    }
    ;

Funcs
    : FuncDecl Funcs {/*empty*/}
    |/*epsilon*/ {/*empty*/}
    ;

FuncDecl
    : OverRide RetType ID LPAREN Formals
    { _stack.insert($2.name, ($4.type + string("->") + $1.type), true, $1.intVal, yylineno);}
    RPAREN LBRACE {_stack.push_scope();} Statements RBRACE {_stack.pop_scope();}
    ;
OverRide
    :/*epsilon*/ {$$.intVal = false;}
    | OVERRIDE {$$.intVal = true;}
    ;

RetType
    : VOID { $$.type=$1.type; } 
    | Type { $$.type=$1.type; }
    ;

Formals
    : /*epsilon*/ {$$.type = string(""); $$.name = string("");  }
    |FormalsList {$$.type = $1.type; $$.name = $1.name;}
    ;

FormalsList
    : FormalDecl {$$.type = $1.type; $$.name = $1.name;}
    | FormalDecl COMMA FormalsList {$$.type = $1.type + string(",") + $3.type;
                                    $$.name = $1.name + string(",") + $3.name;}
    ;
FormalDecl
    : Type ID { $$.type = $1.type ; $$.name = $2.name; }
    ;

Statements
    : Statement {/*empty*/}
    | Statements Statement {/*empty*/}
    ;
Statement 
    : LBRACE {_stack.push_scope();} Statements RBRACE {_stack.pop_scope();}
    | Type ID SC { _stack.insert($2.name , $1.type, false, false, yylineno);}
    | Type ID ASSIGN Exp SC {if(typesDontMatch($1.type, $4.type)) errorMismatch(yylineno); _stack.insert($2.name , $1.type, false, false, yylineno); }
    | ID ASSIGN { if(!_stack.nameExists($1.name) || _stack.isFunc($1.name)) errorUndef(yylineno, $1.name);}
     Exp SC { if(!typesDontMatch(_stack.getType($1.name), $4.type)) errorMismatch(yylineno); }
    | Call SC { /*empty*/ }
    | RETURN SC { if(!isVoid()) errorMismatch(yylineno); }
    | RETURN Exp SC { if(isVoid()) errorMismatch(yylineno); }
    | IF LPAREN Exp RPAREN Statement {if(notBool($3.type)) errorMismatch(yylineno);  }
    | IF LPAREN Exp RPAREN Statement ELSE Statement { if(notBool($3.type)) errorMismatch(yylineno); }
    | WHILE {_stack.updateInWhile(true);} LPAREN Exp RPAREN Statement {if(notBool($3.type)) errorMismatch; _stack.updateInWhile(false);}
    | BREAK SC { if(!_stack.inWhileLoop()) errorUnexpectedBreak(yylineno);}
    | CONTINUE SC { if(!_stack.inWhileLoop()) {errorUnexpectedContinue(yylineno);}}
    ;

Call
    : ID LPAREN ExpList RPAREN { if(expList_not_valid($1.name, $3.type)) errorPrototypeMismatch(yylineno, $1.name); 
    if(!_stack.nameExists($1.name) || !_stack.isFunc($1.name)) errorUndefFunc(yylineno, $1.name);
    $$.name = $1.name; 
    $$.type = _stack.getFunctionreturnType($1.name);
    }
    | ID LPAREN RPAREN { 
    if(expList_not_valid($1.name, string(""))) errorPrototypeMismatch(yylineno, $1.name); 
    if(!_stack.nameExists($1.name) || !_stack.isFunc($1.name)) errorUndefFunc(yylineno, $1.name);
    $$.name = $1.name; 
    $$.type = _stack.getFunctionreturnType($1.name);
    }
    ;
    
ExpList
    : Exp {  $$.type = $1.type; }
    | Exp COMMA ExpList { $$.type = $1.type + string(",") + $3.type; }
    ;

Type
    : INT { $$.type = $1.type; }
    | BYTE { $$.type = $1.type; }
    | BOOL { $$.type = $1.type; }
    ;

Exp
    : LPAREN Exp RPAREN {$$.type = $2.type;}
    | Exp MD_BINOP Exp %prec MD_BINOP { if(notIntOrBool($1.type,$3.type)) errorMismatch(yylineno); $$.type = biggerType($1.type, $3.type); }
    | Exp PM_BINOP Exp %prec PM_BINOP { if(notIntOrBool($1.type,$3.type)) errorMismatch(yylineno); $$.type = biggerType($1.type, $3.type); }
    | ID {if(!_stack.nameExists($1.name) || isFunc($1.type)) errorUndef(yylineno, $1.name); $$.type = $1.type;}
    | Call { $$.type=$1.type; }
    | NUM { $$.type=$1.type; }
    | NUM B {if(byteTooLarge($1.intVal)) errorByteTooLarge(yylineno, $1.strVal); $$.type=$1.type; }
    | STRING { $$.type=$1.type; }
    | TRUE { $$.type=$1.type; }
    | FALSE { $$.type=$1.type; }
    | NOT Exp { if(notBool($2.type)) errorMismatch(yylineno); $$.type=$2.type; }
    | Exp AND Exp { if(notBool($1.type) || notBool($3.type)) errorMismatch(yylineno); $$.type=$1.type; }
    | Exp OR Exp { if(notBool($1.type) || notBool($3.type)) errorMismatch(yylineno); $$.type=$1.type; }
    | Exp EQ_RELOP Exp %prec EQ_RELOP {  if(notIntOrBool($1.type,$3.type)) errorMismatch(yylineno); $$.type = "bool";}
    | Exp RE_RELOP Exp %prec RE_RELOP {  if(notIntOrBool($1.type,$3.type)) errorMismatch(yylineno); $$.type = "bool";}
    | LPAREN Type RPAREN Exp {if(notIntOrBool($2.type,$4.type)) errorMismatch(yylineno);$$.type = $2.type;}
    ;

%%


bool notBool( string type)
{
    if(type==string("bool")) return false;
    return true;
}

bool byteTooLarge(int value)
{
    if(value > 255) return true;
    return false;
}
bool typesDontMatch( string LHS_type,  string RHS_type)
{
    if (LHS_type!=RHS_type && (LHS_type != string("int") || RHS_type != string("byte")))
    {
        return true;
    }
    return false;
}

bool notIntOrBool( string converter_type,  string converted_type)
{
    if((converter_type==string("int") && converted_type==string("bool"))
         ||(converter_type==string("bool") && converted_type==string("int"))
         ||(converter_type==string("int") && converted_type==string("int"))
         ||(converter_type==string("bool") && converted_type==string("bool")))
         {
            return false;
         }
    return true;
}

bool isFunc(string type)
{
    if(type=="func")
    {
        return true;
    }
    return false;
}

bool expList_not_valid(string func_name, string exp_list)
{
    std::vector<std::string> param_vec;
     string params = _stack.getFunctionParamsTypes(func_name);
            if(params!=exp_list)
            {
            errorPrototypeMismatch(yylineno, func_name);
            return true;
            }
            return false;

}
    


bool isVoid()
{
     string func_ret_type = _stack.getCurrentfunctionreturnType();
    if(func_ret_type == string("void"))
    {
        return true;
    }
    else{
        return false;
    }
}
void yyerror( char* s ) 
{
    errorSyn(yylineno);
}

string biggerType(string first, string second)
{
    if(second==string("byte"))
    {
        return second;
    }
    return first;
}


int main()
{
    return yyparse();
}