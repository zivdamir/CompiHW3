%{
    #include <iostream>
    #include "hw3_output.hpp"

    using namespace std;
    using namespace output;
    extern int yylineno;
    int yylex();
    void yyerror(const char*);
    
%}
%define parse.error verbose;
%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc OVERRIDE;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;

%token V;
%token ERROR;
%nonassoc IF;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc LBRACE;
%nonassoc RBRACE;
%nonassoc ID;                                                                      
%nonassoc NUM;    
%nonassoc STRING;

%right ASSIGN;

%left OR;
%left AND;


%left EQ_RELOP;
%left RE_RELOP;
%left PM_BINOP;
%left MD_BINOP;

%right NOT;
%left LPAREN;
%left RPAREN;
%nonassoc ELSE;

%%
Program
    : Funcs { printProductionRule(1); }
    ;

Funcs
    : FuncDecl Funcs { printProductionRule(3); }
    |/*epsilon*/ { printProductionRule(2); }
    ;

FuncDecl
    : OverRide RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { printProductionRule(4); }
    ;
OverRide
    :/*epsilon*/ {printProductionRule(5);}
    | OVERRIDE {printProductionRule(6);}
    ;

RetType
    : VOID { printProductionRule(8); } 
    | Type { printProductionRule(7); }
    ;

Formals
    : /*epsilon*/ { printProductionRule(9); }
    |FormalsList { printProductionRule(10); }
    ;

FormalsList
    : FormalDecl { printProductionRule(11); }
    | FormalDecl COMMA FormalsList { printProductionRule(12); }
    ;
FormalDecl
    : Type ID { printProductionRule(13); }
    ;

Statements
    : Statement { printProductionRule(14); }
    | Statements Statement { printProductionRule(15); }
    ;

Statement
    : LBRACE Statements RBRACE { printProductionRule(16); }
    | Type ID SC { printProductionRule(17); }
    | Type ID ASSIGN Exp SC { if(typesDontMatch($1.type, $4.type)) errorMismatch(yylineno);; }
    | ID ASSIGN Exp SC { if(typesDontMatch($1.type, $4.type)) errorMismatch(yylineno); }
    | Call SC { printProductionRule(20); }
    | RETURN SC { printProductionRule(21); }
    | RETURN Exp SC { printProductionRule(22); }
    | IF LPAREN Exp RPAREN Statement { printProductionRule(23); }
    | IF LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(24); }
    | WHILE LPAREN Exp RPAREN Statement { printProductionRule(25); }
    | BREAK SC { printProductionRule(26); }
    | CONTINUE SC { printProductionRule(27); }
    ;

Call
    : ID LPAREN ExpList RPAREN { printProductionRule(28); }
    | ID LPAREN RPAREN { printProductionRule(29); }
    ;

ExpList
    : Exp { printProductionRule(30); }
    | Exp COMMA ExpList { printProductionRule(31); }
    ;

Type
    : INT { $$.type = "int"; }
    | BYTE { $$.type = "byte"; }
    | BOOL { $$.type = "bool"; }
    ;

Exp
    : LPAREN Exp RPAREN { printProductionRule(35); }
    | Exp MD_BINOP Exp %prec MD_BINOP { if(Exp are not of type number) Error; $$.type=typeWithWidestRange)(/*addhere*/); }
    | Exp PM_BINOP Exp %prec PM_BINOP { if(Exp are not of type number) Error; $$.type=typeWithWidestRange)(/*addhere*/); }
    | ID { printProductionRule(37); }
    | Call { $$.type=$$.type; }
    | NUM { $$.type="int"; }
    | NUM B { $$.type="byte"; }
    | STRING { $$.type="string"; }
    | TRUE { $$.type="bool"; }
    | FALSE { $$.type="bool"; }
    | NOT Exp { if(Exp not of type bool) Error; $$.type="bool"; }
    | Exp AND Exp { if(Exp not of type bool) Error;$$.type="bool"; }
    | Exp OR Exp { if(Exp not of type bool) Error; }
    | Exp EQ_RELOP Exp %prec EQ_RELOP {  if(Exp not numbers) error; $$.type="bool"; }
    | Exp RE_RELOP Exp %prec RE_RELOP {  if(Exp not numbers) error; $$.type="bool"; }
    | LPAREN Type RPAREN Exp { if(badExplicitConvert(/*add here*/)) Error;}; }
    ;

%%
void yyerror(const char* s ) { errorSyn(yylineno);}

bool typesDontMatch(const char* LHS_type, const char* RHS_type)
{
    if((strcmp(type1, type2) != 0)
    && (!(strcmp(LHS_type, "int") == 0 && strcmp(RHS_type, "byte") == 0)))
    {
        return true;
    }
    return false;
}

bool badExplicitConvert(const char* converter_type, const char* converted_type)
{
    if((converter_type=="int" && converted_type=="bool")
         ||(converter_type=="bool" && converted_type=="int")
         ||(converter_type=="int" && converted_type=="int")
         ||(converter_type=="bool" && converted_type=="bool"))
         {
            return false
         }
    return true;
}






int main()
{
    return yyparse();
}